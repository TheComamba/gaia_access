// This code is generated by generate_code.py, do not modify it manually.

//! This module contains all the known columns in the gaiadr2_astrophysical_parameters table.

use crate::traits::{Column, Table};

/// Fouesneau et al. (2022) Gaia DR2 astrophysical parameters. "Astrophysical Parameters from Gaia DR2, 2MASS & AllWISE", Fouesneau et al., 2022, A&A (https://ui.adsabs.harvard.edu/abs/2022arXiv220103252F/abstract). Data replicated from the gdr2ap.main table at the GAVO Data Centre TAP service https://dc.g-vo.org/tap and TAP metadata as of January 2022.
///
/// Original table description: Stellar physical and dynamical properties are essential knowledge to understanding the structure, formation, and evolution of our Galaxy. We produced an all-sky uniformly derived catalog of stellar astrophysical parameters (APs; age, mass, temperature, bolometric luminosity, distance, dust extinction) to give insight into the physical properties of Milky-Way stars. Exploiting the power of multi-wavelength and multi-survey observations from Gaia DR2 parallaxes and integrated photometry along with 2MASS and AllWISE photometry, we introduce an all-sky uniformly derived catalog of stellar astrophysical parameters, including dust extinction (A0) and average grain size (R0) along the line of sight, for 123,076,271 stars. In contrast with previous works, we do not use a Galactic model as prior in our analysis. We validate our results against other literature (e.g., benchmark stars, interferometry, Bayestar, StarHorse). The limited optical information in the Gaia photometric bands or the lack of ultraviolet or spectroscopic information renders the chemistry inference prior dominated. We demonstrate that Gaia parallaxes bring sufficient leverage to explore the detailed structures of the interstellar medium in our Milky Way. In Gaia DR3, we will obtain the dispersed optical light information to break through some limitations of this analysis, allowing us to infer stellar chemistry in particular. Gaia promises us data to construct the most detailed view of the chemo-dynamics of field star populations in our Galaxy.
#[allow(non_camel_case_types)]
pub struct gaiadr2_astrophysical_parameters;

impl Table for gaiadr2_astrophysical_parameters {
    fn string(&self) -> String {
        "gaiadr2_astrophysical_parameters".to_string()
    }
}

/// The columns in the gaiadr2_astrophysical_parameters table.
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, strum::Display)]
pub enum Col {
    /// Unique source identifier. Note that this *cannot* be matched against the DR1 source_id.
    source_id,
    /// multivariate maximum posterior estimate for the dust exctinction A₀ towards this source.
    a0_best,
    /// median of the distribution of dust exctinction A₀ towards this source.
    a0_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the dust exctinction A₀ towards this source. In ADQL, write a0_dist[1] for the minimum, a0_dist[2] for the 16th percentile, and so on.
    a0_dist,
    /// multivariate maximum posterior estimate for the average dust grain size extinction parameter.
    r0_best,
    /// median of the distribution of average dust grain size extinction parameter.
    r0_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the average dust grain size extinction parameter. In ADQL, write r0_dist[1] for the minimum, r0_dist[2] for the 16th percentile, and so on.
    r0_dist,
    /// multivariate maximum posterior estimate for the log10 of the age.
    loga_best,
    /// median of the distribution of log10 of the age.
    loga_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log10 of the age. In ADQL, write loga_dist[1] for the minimum, loga_dist[2] for the 16th percentile, and so on.
    loga_dist,
    /// multivariate maximum posterior estimate for the log10 of the luminosity.
    logl_best,
    /// median of the distribution of log10 of the luminosity.
    logl_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log10 of the luminosity. In ADQL, write logl_dist[1] for the minimum, logl_dist[2] for the 16th percentile, and so on.
    logl_dist,
    /// multivariate maximum posterior estimate for the log10 of the mass.
    logm_best,
    /// median of the distribution of log10 of the mass.
    logm_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log10 of the mass. In ADQL, write logm_dist[1] for the minimum, logm_dist[2] for the 16th percentile, and so on.
    logm_dist,
    /// multivariate maximum posterior estimate for the log10 of the effective temperature.
    logt_best,
    /// median of the distribution of log10 of the effective temperature.
    logt_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log10 of the effective temperature. In ADQL, write logt_dist[1] for the minimum, logt_dist[2] for the 16th percentile, and so on.
    logt_dist,
    /// multivariate maximum posterior estimate for the log10 of the surface gravity.
    logg_best,
    /// median of the distribution of log10 of the surface gravity.
    logg_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log10 of the surface gravity. In ADQL, write logg_dist[1] for the minimum, logg_dist[2] for the 16th percentile, and so on.
    logg_dist,
    /// multivariate maximum posterior estimate for the attenuation in the Gaia BP band towards this source..
    a_bp_best,
    /// median of the distribution of attenuation in the Gaia BP band towards this source..
    a_bp_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the attenuation in the Gaia BP band towards this source.. In ADQL, write a_bp_dist[1] for the minimum, a_bp_dist[2] for the 16th percentile, and so on.
    a_bp_dist,
    /// multivariate maximum posterior estimate for the attenuation in the Gaia G band towards this source..
    a_g_best,
    /// median of the distribution of attenuation in the Gaia G band towards this source..
    a_g_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the attenuation in the Gaia G band towards this source.. In ADQL, write a_g_dist[1] for the minimum, a_g_dist[2] for the 16th percentile, and so on.
    a_g_dist,
    /// multivariate maximum posterior estimate for the attenuation in the Gaia RP band towards this source..
    a_rp_best,
    /// median of the distribution of attenuation in the Gaia RP band towards this source..
    a_rp_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the attenuation in the Gaia RP band towards this source.. In ADQL, write a_rp_dist[1] for the minimum, a_rp_dist[2] for the 16th percentile, and so on.
    a_rp_dist,
    /// Recalibrated Gaia BP magnitude.
    mag_bp,
    /// Recalibrated error from original Gaia BP magnitude.
    err_bp,
    /// multivariate maximum posterior estimate for the Gaia BP magnitude.
    bp_best,
    /// median of the distribution of Gaia BP magnitude.
    bp_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the Gaia BP magnitude. In ADQL, write bp_dist[1] for the minimum, bp_dist[2] for the 16th percentile, and so on.
    bp_dist,
    /// Recalibrated Gaia G magnitude.
    mag_g,
    /// Recalibrated error from original Gaia G magnitude.
    err_g,
    /// multivariate maximum posterior estimate for the Gaia G magnitude.
    g_best,
    /// median of the distribution of Gaia G magnitude.
    g_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the Gaia G magnitude. In ADQL, write g_dist[1] for the minimum, g_dist[2] for the 16th percentile, and so on.
    g_dist,
    /// Recalibrated Gaia RP magnitude.
    mag_rp,
    /// Recalibrated error from original Gaia RP magnitude.
    err_rp,
    /// multivariate maximum posterior estimate for the Gaia RP magnitude.
    rp_best,
    /// median of the distribution of Gaia RP magnitude.
    rp_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the Gaia RP magnitude. In ADQL, write rp_dist[1] for the minimum, rp_dist[2] for the 16th percentile, and so on.
    rp_dist,
    /// Recalibrated 2MASS J magnitude.
    mag_j,
    /// Recalibrated error from original 2MASS J magnitude.
    err_j,
    /// multivariate maximum posterior estimate for the 2MASS J magnitude.
    j_best,
    /// median of the distribution of 2MASS J magnitude.
    j_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the 2MASS J magnitude. In ADQL, write j_dist[1] for the minimum, j_dist[2] for the 16th percentile, and so on.
    j_dist,
    /// Recalibrated 2MASS H magnitude.
    mag_h,
    /// Recalibrated error from original 2MASS H magnitude.
    err_h,
    /// multivariate maximum posterior estimate for the 2MASS H magnitude.
    h_best,
    /// median of the distribution of 2MASS H magnitude.
    h_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the 2MASS H magnitude. In ADQL, write h_dist[1] for the minimum, h_dist[2] for the 16th percentile, and so on.
    h_dist,
    /// Recalibrated 2MASS Ks magnitude.
    mag_ks,
    /// Recalibrated error from original 2MASS Ks magnitude.
    err_ks,
    /// multivariate maximum posterior estimate for the 2MASS Ks magnitude.
    ks_best,
    /// median of the distribution of 2MASS Ks magnitude.
    ks_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the 2MASS Ks magnitude. In ADQL, write ks_dist[1] for the minimum, ks_dist[2] for the 16th percentile, and so on.
    ks_dist,
    /// Recalibrated WISE W1 magnitude.
    mag_w1,
    /// Recalibrated error from original WISE W1 magnitude.
    err_w1,
    /// multivariate maximum posterior estimate for the WISE W1 magnitude.
    w1_best,
    /// median of the distribution of WISE W1 magnitude.
    w1_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the WISE W1 magnitude. In ADQL, write w1_dist[1] for the minimum, w1_dist[2] for the 16th percentile, and so on.
    w1_dist,
    /// Recalibrated WISE W2 magnitude.
    mag_w2,
    /// Recalibrated error from original WISE W2 magnitude.
    err_w2,
    /// multivariate maximum posterior estimate for the WISE W2 magnitude.
    w2_best,
    /// median of the distribution of WISE W2 magnitude.
    w2_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the WISE W2 magnitude. In ADQL, write w2_dist[1] for the minimum, w2_dist[2] for the 16th percentile, and so on.
    w2_dist,
    /// multivariate maximum posterior estimate for the distance modulus.
    dmod_best,
    /// median of the distribution of distance modulus.
    dmod_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the distance modulus. In ADQL, write dmod_dist[1] for the minimum, dmod_dist[2] for the 16th percentile, and so on.
    dmod_dist,
    /// multivariate maximum posterior estimate for the log likelihood of the solution (paper Eq. 1).
    lnlike_best,
    /// median of the distribution of log likelihood of the solution (paper Eq. 1).
    lnlike_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log likelihood of the solution (paper Eq. 1). In ADQL, write lnlike_dist[1] for the minimum, lnlike_dist[2] for the 16th percentile, and so on.
    lnlike_dist,
    /// multivariate maximum posterior estimate for the log posterior of the solution (paper Eq. 2).
    lnp_best,
    /// median of the distribution of log posterior of the solution (paper Eq. 2).
    lnp_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log posterior of the solution (paper Eq. 2). In ADQL, write lnp_dist[1] for the minimum, lnp_dist[2] for the 16th percentile, and so on.
    lnp_dist,
    /// multivariate maximum posterior estimate for the log photometric likelihood jitter common to all bands.
    log10jitter_best,
    /// median of the distribution of log photometric likelihood jitter common to all bands.
    log10jitter_p50,
    /// Distribution (min, p16, p25, p50, p75, p84, max) of the log photometric likelihood jitter common to all bands. In ADQL, write log10jitter_dist[1] for the minimum, log10jitter_dist[2] for the 16th percentile, and so on.
    log10jitter_dist,
    /// Recalibrated parallax.
    parallax,
    /// Error in recalibrated parallax.
    err_parallax,
}

impl Column for Col {}

#[cfg(test)]
/// Collects all the known columns in the gaiadr2_astrophysical_parameters table.
pub fn collect_known(map: &mut std::collections::HashMap<String, Vec<String>>) {
    let mut col_strings = Vec::new();
    col_strings.push(Col::source_id.to_string());
    col_strings.push(Col::a0_best.to_string());
    col_strings.push(Col::a0_p50.to_string());
    col_strings.push(Col::a0_dist.to_string());
    col_strings.push(Col::r0_best.to_string());
    col_strings.push(Col::r0_p50.to_string());
    col_strings.push(Col::r0_dist.to_string());
    col_strings.push(Col::loga_best.to_string());
    col_strings.push(Col::loga_p50.to_string());
    col_strings.push(Col::loga_dist.to_string());
    col_strings.push(Col::logl_best.to_string());
    col_strings.push(Col::logl_p50.to_string());
    col_strings.push(Col::logl_dist.to_string());
    col_strings.push(Col::logm_best.to_string());
    col_strings.push(Col::logm_p50.to_string());
    col_strings.push(Col::logm_dist.to_string());
    col_strings.push(Col::logt_best.to_string());
    col_strings.push(Col::logt_p50.to_string());
    col_strings.push(Col::logt_dist.to_string());
    col_strings.push(Col::logg_best.to_string());
    col_strings.push(Col::logg_p50.to_string());
    col_strings.push(Col::logg_dist.to_string());
    col_strings.push(Col::a_bp_best.to_string());
    col_strings.push(Col::a_bp_p50.to_string());
    col_strings.push(Col::a_bp_dist.to_string());
    col_strings.push(Col::a_g_best.to_string());
    col_strings.push(Col::a_g_p50.to_string());
    col_strings.push(Col::a_g_dist.to_string());
    col_strings.push(Col::a_rp_best.to_string());
    col_strings.push(Col::a_rp_p50.to_string());
    col_strings.push(Col::a_rp_dist.to_string());
    col_strings.push(Col::mag_bp.to_string());
    col_strings.push(Col::err_bp.to_string());
    col_strings.push(Col::bp_best.to_string());
    col_strings.push(Col::bp_p50.to_string());
    col_strings.push(Col::bp_dist.to_string());
    col_strings.push(Col::mag_g.to_string());
    col_strings.push(Col::err_g.to_string());
    col_strings.push(Col::g_best.to_string());
    col_strings.push(Col::g_p50.to_string());
    col_strings.push(Col::g_dist.to_string());
    col_strings.push(Col::mag_rp.to_string());
    col_strings.push(Col::err_rp.to_string());
    col_strings.push(Col::rp_best.to_string());
    col_strings.push(Col::rp_p50.to_string());
    col_strings.push(Col::rp_dist.to_string());
    col_strings.push(Col::mag_j.to_string());
    col_strings.push(Col::err_j.to_string());
    col_strings.push(Col::j_best.to_string());
    col_strings.push(Col::j_p50.to_string());
    col_strings.push(Col::j_dist.to_string());
    col_strings.push(Col::mag_h.to_string());
    col_strings.push(Col::err_h.to_string());
    col_strings.push(Col::h_best.to_string());
    col_strings.push(Col::h_p50.to_string());
    col_strings.push(Col::h_dist.to_string());
    col_strings.push(Col::mag_ks.to_string());
    col_strings.push(Col::err_ks.to_string());
    col_strings.push(Col::ks_best.to_string());
    col_strings.push(Col::ks_p50.to_string());
    col_strings.push(Col::ks_dist.to_string());
    col_strings.push(Col::mag_w1.to_string());
    col_strings.push(Col::err_w1.to_string());
    col_strings.push(Col::w1_best.to_string());
    col_strings.push(Col::w1_p50.to_string());
    col_strings.push(Col::w1_dist.to_string());
    col_strings.push(Col::mag_w2.to_string());
    col_strings.push(Col::err_w2.to_string());
    col_strings.push(Col::w2_best.to_string());
    col_strings.push(Col::w2_p50.to_string());
    col_strings.push(Col::w2_dist.to_string());
    col_strings.push(Col::dmod_best.to_string());
    col_strings.push(Col::dmod_p50.to_string());
    col_strings.push(Col::dmod_dist.to_string());
    col_strings.push(Col::lnlike_best.to_string());
    col_strings.push(Col::lnlike_p50.to_string());
    col_strings.push(Col::lnlike_dist.to_string());
    col_strings.push(Col::lnp_best.to_string());
    col_strings.push(Col::lnp_p50.to_string());
    col_strings.push(Col::lnp_dist.to_string());
    col_strings.push(Col::log10jitter_best.to_string());
    col_strings.push(Col::log10jitter_p50.to_string());
    col_strings.push(Col::log10jitter_dist.to_string());
    col_strings.push(Col::parallax.to_string());
    col_strings.push(Col::err_parallax.to_string());
    map.insert(gaiadr2_astrophysical_parameters.string(), col_strings);
}
