// This code is generated by generate_code.py, do not modify it manually.

//! This module contains all the known columns in the commanded_scan_law table.

use crate::traits::{Column, Table};

/// This table provides a representation of the Gaia scanning law over the
/// 34 month time period covered by the Gaia Data Release 3 (from 2014-07-25
/// 10:31:26 to 2017-05-28 08:46:29), including the Ecliptic Pole Scanning
/// at the begin of the mission. Note that this is the commanded attitude of
/// the spacecraft, the actual attitude could deviate from it by up to about
/// 30 arcsec. Also, it does not contain any of the data interruptions that
/// occurred during the real mission, of which the main ones are listed in
/// Chapter [chap:cu0int], Section [cu0int_sec:release_framework].
///
/// The scanning law has been sampled at a 10 second interval, in which the
/// satellite rotates about 10 arcminutes (the target spin rate is actually
/// 59.9641857803 arcsec/sec). Note that this is several times shorter than
/// a typical field-of-view transit and the scan position angle will be
/// practically constant during this interval.
///
/// Notes:
///
/// -   The times in columns 1, 2 and 3 are in Julian days in TCB with time
///     origin 2010-01-01T00:00 (JD 2455197.5), following the time
///     coordinate convention used in the Gaia archive. TCB stands for
///     Barycentric Coordinate Time and is the time standard used in Gaia
///     processing, equivalent to the proper time experienced by a clock at
///     rest in a coordinate frame co-moving with the barycentre of the
///     Solar system but outside its gravity well, therefore not influenced
///     by the gravitational time dilation caused by the Sun and the rest of
///     the solar system.
///
/// -   Column 1 is the reference time for the spacecraft attitude, while
///     columns 2 and 3 give the times with the (relativistic) corrections
///     applied for the light-travel time to the solar system barycentre,
///     corresponding to an infinitely distant source at the RA, DEC at the
///     centres of FOV 1 and 2, respectively.
///
/// -   FOV1 and FOV2 correspond to the preceding (PFOV) and following
///     (FFOV) fields-of-view, respectively.
///
/// -   The centres of the field of views are separated by the basic angle
///     of 106.5 deg, see Fig. 2 of . Their origin in the focal plane is
///     illustrated in Fig. 3 of the same paper: both originate in the
///     astrometric field (AF) 7, with FOV1 in row 3 and FOV2 in row 5.
///
/// -   The scan angle, theta, is the position angle of the direction in
///     which the FOV is moving (also called ‘along-scan’ direction), and is
///     defined in the usual astronomical sense: theta = 0 when the FoV is
///     moving towards local North, and theta = 90 degrees towards local
///     East.
///
/// -   All values have been formatted to the default double numerical
///     precision and so this precision should not be interpreted as the
///     accuracy of the data.
#[allow(non_camel_case_types)]
pub struct commanded_scan_law;

impl Table for commanded_scan_law {
    fn string(&self) -> String {
        "commanded_scan_law".to_string()
    }
}

/// The columns in the commanded_scan_law table.
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, strum::Display)]
pub enum Col {
    /// Time [Julian Date in TCB at Gaia - 2455197.5]
    jd_time,
    /// Time [Julian Date in TCB at barycentre for FOV1 - 2455197.5]
    bjd_fov1,
    /// Time [Julian Date in TCB at barycentre for FOV2 - 2455197.5]
    bjd_fov2,
    /// Time at Gaia (OBMT)
    obmt_time,
    /// Right Ascension of FOV1 centre
    ra_fov1,
    /// Declination of FOV1 centre
    dec_fov1,
    /// FOV1 HEALPix level 12
    heal_pix_fov1,
    /// Scan position angle of FOV1
    scan_angle_fov1,
    /// Right ascension of FOV2 centre
    ra_fov2,
    /// Declination of FOV2 centre
    dec_fov2,
    /// FOV2 HEALPix level 12
    heal_pix_fov2,
    /// Scan position angle of FOV2
    scan_angle_fov2,
    /// Solution Identifier
    solution_id,
}

impl Column for Col {}

#[cfg(test)]
pub fn collect_known(map: &mut std::collections::HashMap<String, Vec<String>>) {
    let mut col_strings = Vec::new();
    col_strings.push(Col::jd_time.to_string());
    col_strings.push(Col::bjd_fov1.to_string());
    col_strings.push(Col::bjd_fov2.to_string());
    col_strings.push(Col::obmt_time.to_string());
    col_strings.push(Col::ra_fov1.to_string());
    col_strings.push(Col::dec_fov1.to_string());
    col_strings.push(Col::heal_pix_fov1.to_string());
    col_strings.push(Col::scan_angle_fov1.to_string());
    col_strings.push(Col::ra_fov2.to_string());
    col_strings.push(Col::dec_fov2.to_string());
    col_strings.push(Col::heal_pix_fov2.to_string());
    col_strings.push(Col::scan_angle_fov2.to_string());
    col_strings.push(Col::solution_id.to_string());
    map.insert(commanded_scan_law.string(), col_strings);
}
