// This code is generated by generate_code.py, do not modify it manually.

//! This module contains all the known columns in the rrlyrae table.

use crate::traits::{Column, Table};

/// This table describes the RRLyrae stars identified in table
/// VariableSummary as classification=“RRLYR”. In the analyses only
/// observations with rejectedByVariabilityProcessing=false are included, as
/// found in table PhotVariableTimeSeriesGfov.
#[allow(non_camel_case_types)]
pub struct rrlyrae;

impl Table for rrlyrae {
    fn string(&self) -> String {
        "rrlyrae".to_string()
    }
}

/// The columns in the rrlyrae table.
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, strum::Display)]
pub enum Col {
    /// Classification of an RR Lyrae star according to the pulsation mode: RRc
    /// (“RRC”) for first overtone and RRab (“RRAB”) for fundamental mode,
    /// obtained using the period-amplitude diagram in the G-band and the plots
    /// of the Fourier parameters R21 and Phi2 vs period.
    best_classification,
    /// All Gaia data processed by the Data Processing and Analysis Consortium
    /// comes tagged with a solution identifier. This is a numeric field
    /// attached to each table row that can be used to unequivocally identify
    /// the version of all the subsystems that where used in the generation of
    /// the data as well as the input data used. It is mainly for internal DPAC
    /// use but is included in the published data releases to enable end users
    /// to examine the provenance of processed data products. To decode a given
    /// solution ID visit
    solution_id,
    /// A unique single numerical identifier of the source obtained from
    /// GaiaSource (for a detailed description see GaiaSource.sourceId)
    source_id,
    /// This parameter is filled with the period of the maximum power peak in
    /// the frequencygram obtained from the modeling of the time series. The
    /// light curve of the target star is modeled with a truncated Fourier
    /// series (mag(t_j)=zp+\sum[A_i sin(i \times 2 \pi \nu_{max}t_j +\phi_i)]).
    /// Zero-point (zp), period (1/\nu_{max}), number of harmonics (i),
    /// amplitudes (A_i), and phases (\phi_i) of the harmonics, for the G-band
    /// light curve are determined using the Levenberg-Marquardt non linear
    /// fitting algorithm.
    p1,
    /// This parameter is filled with the uncertainty value of the p1 parameter.
    /// Its value is derived with Monte Carlo simulations that generate several
    /// (100) time series with the same time path as the data points but with
    /// magnitudes generated randomly around the corresponding data value. For
    /// each of these time series the period is derived from the non linear
    /// modeling with a truncated Fourier series of the light curve. The mean of
    /// all the periods found and its standard deviation are then computed, and
    /// the latter value is kept as value to fill the p1Error parameter.
    p1_error,
    /// The epoch of maximum light for the Gaia integrated G band. It
    /// corresponds to the Baricentric Julian day (BJD) of the maximum value of
    /// the light curve model which is closest to the BJD of the first
    /// observations -3\timesp1.
    ///
    /// The mentioned BJD is offset by JD 2455197.5 (= J2010.0).
    epoch_g,
    /// The uncertainty value of the epochG parameter. Its value is three times
    /// the error on the p1.
    epoch_g_error,
    /// The intensity-averaged magnitude in the G-band. The intensity-averaged
    /// magnitude is obtained by computing the average flux and then converting
    /// the average flux to magnitude.
    int_average_g,
    /// This parameter is filled with the uncertainty value of the intAverageG
    /// parameter. The uncertainty is computed as the error(zp), where zp is the
    /// zero point obtained by the non linear Fourier modeling of the light
    /// curve.
    int_average_g_error,
    /// This parameter is filled with the peak-to-peak amplitude value of the G
    /// band light curve. The peak-to-peak amplitude is calculated as the
    /// (maximum) - (minimum) of the folded modeled light curve in the G band.
    /// The light curve of the target star is modeled with a truncated Fourier
    /// series (mag(t_j)=zp+\sum[A_i sin(i \times 2 \pi \nu_{max}t_j
    ///   +\phi_i)]). Zero-point (zp), period (1/\nu_{max}), number of harmonics
    /// (i), amplitudes (A_i), and phases (\phi_i) of the harmonics, for the
    /// G-band light curve are determined using the Levenberg-Marquardt non
    /// linear fitting algorithm.
    peak_to_peak_g,
    /// This parameter is filled with the uncertainty value of the peakToPeakG
    /// parameter. The uncertainty is computed as the \sqrt{2}\times error(zp),
    /// where zp is the zero point obtained by the non linear Fourier modeling
    /// of the light curve.
    peak_to_peak_g_error,
    /// This parameter is filled with the number of harmonics used to model P1
    /// of the light curve. The light curve of the target star is modeled with a
    /// truncated Fourier series
    /// (mag(t_j)=zp+\sum[A_i sin(i \times 2 \pi \nu_{max}t_j +\phi_i)]).
    /// Zero-point (zp), period (1/\nu_{max}), number of harmonics (i),
    /// amplitudes (A_i), and phases (\phi_i) of the harmonics are determined
    /// using the Levenberg-Marquardt non linear fitting algorithm.
    num_harmonics_for_p1,
    /// This parameter is filled with the Fourier decomposition parameter
    /// R_{21} = A_2/A_1, where A_2 is the amplitude of the 2nd harmonic and
    /// A_{1} is the amplitude of the fundamental harmonic of the truncated
    /// Fourier series defined hereafter. The light curve of the target star is
    /// modeled with a truncated Fourier series
    /// (mag(t_j)=zp+\sum[A_i sin(i \times 2 \pi \nu_{max}t_j +\phi_i)]).
    /// Zero-point (zp), period (1/\nu_{max}), number of harmonics (i),
    /// amplitudes (A_i), and phases (\phi_i) of the harmonics, are determined
    /// using the Levenberg-Marquardt non linear fitting algorithm.
    r21_g,
    /// This parameter is filled with the uncertainty value on the r21G
    /// parameter. Its value isderived by propagation of the errors in the A2
    /// and A1 parameters. Errors in A1,A2 are computed from Monte Carlo
    /// simulations that generate several (100) time series with the same time
    /// path as the data points but with magnitudes generated randomly around
    /// the corresponding data value. The mean for each of these values and
    /// their standard deviations are then computed, and the latter values are
    /// kept as value to fill the uncertainty of the A1, A2 parameters.
    r21_g_error,
    /// This parameter is filled with the Fourier decomposition parameter
    /// \phi_{21}: \phi_2 - 2\phi_1 value. The light curve of the target star is
    /// modeled with a truncated Fourier series (mag(t_j)=zp+\sum[A_i
    ///   sin(i \times 2 \pi \nu_{max} t_j +\phi_i)]). Zero-point (zp), period
    /// (1/\nu_{max}), number of harmonics (i), amplitudes (A_i), and phases
    /// (\phi_i) of the harmonics, for the G-band light curve are determined
    /// using the Levenberg-Marquardt non linear fitting algorithm.
    phi21_g,
    /// This parameter is filled with the uncertainty of the phi21G parameter.
    /// Its value is derived by propagation of the errors in the phi1 and phi2
    /// parameters. Errors in phi1,phi2 are computed from Monte Carlo
    /// simulations that generate several (100) time series with the same time
    /// path as the data points but with magnitudes generated randomly around
    /// the corresponding data value. For each of these time series the phi1,
    /// phi2 values are computed. The mean for each of these values and their
    /// standard deviation are then computed, and the latter values are kept as
    /// value to fill the uncertainty of the phi1 and phi2 parameters.
    phi21_g_error,
}

impl Column for Col {}

#[cfg(test)]
/// Collects all the known columns in the rrlyrae table.
pub fn collect_known(map: &mut std::collections::HashMap<String, Vec<String>>) {
    let mut col_strings = Vec::new();
    col_strings.push(Col::best_classification.to_string());
    col_strings.push(Col::solution_id.to_string());
    col_strings.push(Col::source_id.to_string());
    col_strings.push(Col::p1.to_string());
    col_strings.push(Col::p1_error.to_string());
    col_strings.push(Col::epoch_g.to_string());
    col_strings.push(Col::epoch_g_error.to_string());
    col_strings.push(Col::int_average_g.to_string());
    col_strings.push(Col::int_average_g_error.to_string());
    col_strings.push(Col::peak_to_peak_g.to_string());
    col_strings.push(Col::peak_to_peak_g_error.to_string());
    col_strings.push(Col::num_harmonics_for_p1.to_string());
    col_strings.push(Col::r21_g.to_string());
    col_strings.push(Col::r21_g_error.to_string());
    col_strings.push(Col::phi21_g.to_string());
    col_strings.push(Col::phi21_g_error.to_string());
    map.insert(rrlyrae.string(), col_strings);
}
